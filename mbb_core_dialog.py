# -*- coding: utf-8 -*-
"""
/***************************************************************************
 mbb_qgis_pluginDialog
                                 A QGIS plugin
  A tool to automatically set up QGIS Atlas layouts

 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2019-07-17
        git sha              : $Format:%H$
        copyright            : (C) 2019 by Anthony Cooper
        email                : anthony.cooper@outlook.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os

from qgis.PyQt import uic
from qgis.PyQt import QtWidgets
from qgis.PyQt.QtWidgets import *
from qgis.core import *


# This loads your .ui file so that PyQt can populate your plugin with the elements from Qt Designer
FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'mbb_core_dialog_base.ui'))


class mbb_qgis_pluginDialog(QtWidgets.QDialog, FORM_CLASS):
    def __init__(self, parent=None):
        """Constructor."""
        super(mbb_qgis_pluginDialog, self).__init__(parent)
        # Set up the user interface from Designer through FORM_CLASS.
        # After self.setupUi() you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://qt-project.org/doc/qt-4.8/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setupUi(self)

        self.stackedWidget.setCurrentIndex(0)
        self.update_buttons()
        self.stackedWidget.currentChanged.connect(self.update_buttons)
        self.nextButton.clicked.connect(self.__next__)
        self.prevButton.clicked.connect(self.prev)
        self.tAdd.clicked.connect(lambda: self.addDynamicItem(0))
        self.eAdd.clicked.connect(lambda: self.addDynamicItem(1))
        self.sAdd.clicked.connect(lambda: self.addDynamicItem(2))
        self.sAdd_2.clicked.connect(lambda: self.addDynamicItem(3))
        self.sTree.clear()
        self.eList.clear()
        self.tList.clear()




    def  update_buttons(self):
        i = self.stackedWidget.currentIndex()
        self.prevButton.setEnabled(i > 0)
        if i == (self.stackedWidget.count()-1):
            self.nextButton.setText('Generate Atlas')
        else:
            self.nextButton.setText('Next >')

    def prev(self):
        i = self.stackedWidget.currentIndex()
        self.stackedWidget.setCurrentIndex(i - 1)
        self.update_buttons()

    def __next__(self):
        i = self.stackedWidget.currentIndex()

        validEntry = True

        #Check valid entry for sheet #, and prep next sheet
        if i == 0:                          #Setup
            validEntry = self.setup()
        if i == 1:                          #Template
            validEntry = self.setup()
        if i == 2:                          #Consistent
            validEntry = self.setup()
        if i == 3:                          #Dynamic
            validEntry = self.dynamicLayersList()
        if i == 4:                          #Review
            validEntry = self.setup()



        if validEntry:      #If valid entry (if not valid entry, do nothing else)
            if i < self.stackedWidget.count()-1:    #if before final sheet
                self.stackedWidget.setCurrentIndex(i + 1)   #move to next
                self.update_buttons()   #update the buttons
            else:
                self.accept()   #return to main run, do the generation

    def setup(self):
        #If using existing template is it valid file
            #return False

        #If saving new copy is it valid location
            #return False

        #Take template (default or existing) and load in data

        self.layers = []

        # Fetch the currently loaded layers
        self.layers = self.load_all_layers(QgsProject.instance().layerTreeRoot().children(), self.layers)



        return True

    def dynamicLayersList(self):
        layers = self.layers.copy()
        searchLists = [[],[],[]]
        searchLists[0] = (['h_Max', 'd_Max'])
        searchLists[1] = (['0020', '0100', 'C100'])
        searchLists[2] = ([['BASE',['']],['DEVELOPED',['','DEFENDED']]])

        for searchList in searchLists:
            layers = self.deepSearch(layers,searchList)

        self.previewList.clear()
        for layer in layers:
            self.previewList.addItem(layer.name())

    def deepSearch(self, layers, searchList):
        output = []
        for search in searchList:
            research = []
            found = []
            if type(search) == list:
                for layer in layers:
                    if (search[0] == '') and (len(searchList) > 1):
                        negSearch = searchList.copy()
                        negSearch.remove(search)
                        if any(x[0] not in layer.name() for x in negSearch):
                            output.append(layer)
                            found.append(layer)
                    else:
                        if search[0] in layer.name():
                            research.append(layer)
                            found.append(layer)
                for layer in found:
                    layers.remove(layer)
                for item in self.deepSearch(research, search[1]):
                    output.append(item)
            else:

                for layer in layers:
                    if (search == '') and (len(searchList) > 1):
                        negSearch = searchList.copy()
                        negSearch.remove(search)
                        if any(x not in layer.name() for x in negSearch):
                            output.append(layer)
                            found.append(layer)
                    else:
                        if search in layer.name():
                            output.append(layer)
                            found.append(layer)
                for layer in found:
                    layers.remove(layer)



        return output

    def addDynamicItem(self,ty):
        item = 'str'
        if ty == 0:
            self.tList.addItem(item)
        elif ty == 1:
            self.eList.addItem(item)
        elif ty == 2:
            twi = QTreeWidgetItem(self.sTree,[item],0)
            twi.addChild(QTreeWidgetItem(['Others'],0))
            self.sTree.expandItem(twi)
        elif ty == 3:
            twi = self.sTree.currentItem()
            twi.addChild(QTreeWidgetItem([item],0))
            self.sTree.expandItem(twi)


    def load_all_layers(self, group, layers):
        for child in group:
            if isinstance(child, QgsLayerTreeLayer):
                layers.append(child)
            elif isinstance(child, QgsLayerTreeGroup):
                layers = self.load_all_layers(child.children(), layers)
        return layers
