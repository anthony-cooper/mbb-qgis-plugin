# -*- coding: utf-8 -*-
"""
/***************************************************************************
 mbb_qgis_pluginDialog
                                 A QGIS plugin
  A tool to automatically set up QGIS Atlas layouts

 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2019-07-17
        git sha              : $Format:%H$
        copyright            : (C) 2019 by Anthony Cooper
        email                : anthony.cooper@outlook.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os
import csv
from qgis.PyQt import uic
from qgis.PyQt import QtWidgets
from qgis.PyQt.QtWidgets import *
from qgis.PyQt.QtXml import QDomDocument
from qgis.core import *
from .mbb_core_dialog_additem import mbb_dialog_additem
from .mbb_core_dialog_addmap import mbb_dialog_addmap
from .mbb_core_dialog_addproperty import mbb_dialog_addproperty



# This loads your .ui file so that PyQt can populate your plugin with the elements from Qt Designer
FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'mbb_core_dialog_base.ui'))


class mbb_qgis_pluginDialog(QtWidgets.QDialog, FORM_CLASS):


    def __init__(self, parent=None):
        """Constructor."""
        super(mbb_qgis_pluginDialog, self).__init__(parent)
        # Set up the user interface from Designer through FORM_CLASS.
        # After self.setupUi() you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://qt-project.org/doc/qt-4.8/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setupUi(self)

        self.stackedWidget.setCurrentIndex(0)
        self.update_buttons()
        self.stackedWidget.currentChanged.connect(self.update_buttons)
        self.nextButton.clicked.connect(self.__next__)
        self.prevButton.clicked.connect(self.prev)

        self.addCriteria.clicked.connect(lambda: self.addCriteriaTab())
        self.addProperty.clicked.connect(lambda: self.addPropertyItem())
        self.removeCriteria.clicked.connect(lambda: self.removeCriteriaTab())
        self.removeProperty.clicked.connect(lambda: self.removePropertyItem())
        self.upCriteria.clicked.connect(lambda: self.moveUpCriteriaTab())
        self.upProperty.clicked.connect(lambda: self.moveUpPropertyItem())
        self.deselProperty.clicked.connect(lambda: self.deselectProperty())

        self.addSDL.clicked.connect(lambda: self.addSDLTab())
        self.addSDLC.clicked.connect(lambda: self.addSDLCriteria())
        self.addSDLExistingP.clicked.connect(lambda: self.addSDLExistingProperty())
        self.addSDLI.clicked.connect(lambda: self.addSDLItem())
        self.addSDLP.clicked.connect(lambda: self.addSDLProperty())
        self.removeSDL.clicked.connect(lambda: self.removeSDLTab())
        self.removeSDLI.clicked.connect(lambda: self.removeSDLItem())
        self.removeSDLF.clicked.connect(lambda: self.removeSDLFeature())



        self.addMap.clicked.connect(lambda: self.addMapItem())
        self.removeMap.clicked.connect(lambda: self.removeMapItem())
        self.upMap.clicked.connect(lambda: self.moveUpMapItem())


        self.existingTemplateBrowser.clicked.connect(lambda: self.loadExistingFile(self.existingTemplate, 'QGIS Print Composer Template (*.qpt)'))


        self.otherItem = 'All (Other) Items'

        #defaults for setup file


        self.mapName = 'TEST'






    def  update_buttons(self):
        i = self.stackedWidget.currentIndex()
        self.prevButton.setEnabled(i > 0)
        if i == (self.stackedWidget.count()-1):
            self.nextButton.setText('Generate Atlas')
        else:
            self.nextButton.setText('Next >')

    def prev(self):
        i = self.stackedWidget.currentIndex()
        self.stackedWidget.setCurrentIndex(i - 1)
        self.update_buttons()

    def __next__(self):
        name = (self.stackedWidget.currentWidget()).objectName()
        i = self.stackedWidget.currentIndex()
        validEntry = False

        #Check valid entry for sheet #, and prep next sheet
        if name == 'Setup':                                    #Setup
            validEntry = self.setup()
        if name == 'Template':                                 #Template
            validEntry = self.setupTemplate()
            if self.criteriaTabs.count() == 0:
                self.addCriteriaTab()
        if name == 'Dynamic':                                  #Lead Dynamic Layer
            validEntry = self.dynamicLayersList()
        if name == 'DynamicDetails':                           #Dynamic details
            validEntry = self.confirmDynamicDetails()
            validEntry = self.selectMapItems()
        if name == 'Maps':                                     #Maps
            validEntry = self.confirmMapItems()



        if validEntry:      #If valid entry (if not valid entry, do nothing else)
            if i < self.stackedWidget.count()-1:    #if before final sheet
                self.stackedWidget.setCurrentIndex(i + 1)   #move to next
                self.update_buttons()   #update the buttons
            else:
                self.writeSetupFile()
                if self.newLayout: #Check if new layout and load if neccessary
                    manager = QgsProject.instance().layoutManager()
                    manager.addLayout(self.template)

                self.accept()   #return to main run, do the generation

    def setup(self):
        #If using existing template is it valid file
            #return False

        #If saving new copy is it valid location
            #return False

        self.setupPath = os.path.abspath(QgsProject.instance().homePath())
        self.setupName = 'test'

        #Take template (default or existing) and load in data

        self.layers = []

        # Fetch the currently loaded layers
        #self.layers = self.load_all_layers(QgsProject.instance().layerTreeRoot().children(), self.layers)
        lyrs = QgsProject.instance().mapLayers()
        for layer_id, layer in lyrs.items():
            self.layers.append([layer,[]])



        # Fetch the current project layouts
        manager = QgsProject.instance().layoutManager()
        self.allLayoutNames = []

        if len(manager.printLayouts()) == 0:
            self.existingLayout.setCheckable(False)
            self.existingLayout.setChecked(False)
        else:
            self.existingLayouts.clear()
            self.existingLayout.setCheckable(True)
            for layout in manager.printLayouts():
                self.allLayoutNames.append(layout.name())
            self.existingLayouts.addItems(self.allLayoutNames)
        return True

    def writeSetupFile(self):
        #Prep header
        headerQMS = []
        headerQMS.append(['<<HEADER>>', 3])
        headerQMS.extend(self.mapsDetailsQMS)
        headerQMS.append(['<<END OF HEADER>>'])
        self.headerLength = len(headerQMS)
        headerQMS[0][1] = self.headerLength

        mapDetailsHeader = ['MAP','easting','northing']
        mapDetails = ['MAP',0,0]

        layersHeaderQMS = []
        layersHeaderQMS.extend(mapDetailsHeader)
        layersHeaderQMS.append('Lead Dynamic Layer')
        for i in range(0, self.criteriaTabs.count()):
            layersHeaderQMS.append(self.criteriaTabs.tabText(i))
        for i in range(0, self.mapItems.count()):
            layersHeaderQMS.append(self.mapItems.tabText(i) + '_Layers')


        if os.path.exists(os.path.join(self.setupPath, self.setupName + ".QMapSetup")):
            os.remove(os.path.join(self.setupPath, self.setupName + ".QMapSetup"))

        with open(os.path.join(self.setupPath, self.setupName + ".QMapSetup"), 'w+', newline='') as file:
            writer = csv.writer(file)
            writer.writerows(headerQMS)
            writer.writerow(layersHeaderQMS)


            iterator = QTreeWidgetItemIterator(self.previewTree)
            while iterator.value():
                item = iterator.value()
                layerRow = []
                layerRow.extend(mapDetails)
                for i in range(0, item.columnCount()):
                    layerRow.append(item.text(i))

                for i in range(0, self.mapItems.count()):
                    tab = self.mapItems.widget(i)
                    treeWidget = tab.children()[1]
                    mapIterator = QTreeWidgetItemIterator(treeWidget)
                    mapLayers = []
                    while mapIterator.value():
                        mapItem = mapIterator.value()
                        if mapItem.text(0) == '<><> LEAD DYNAMIC LAYER <><>':
                            mapLayers.append(item.text(0))
                        else:
                            mapLayers.append(mapItem.text(0))
                        mapIterator += 1
                    layerRow.append('|'.join(mapLayers))





                writer.writerow(layerRow)
                iterator += 1

#Lead Dynamic Layers
    def addCriteriaTab(self):
        self.additem_dlg = mbb_dialog_additem()
        self.additem_dlg.show()
        result = self.additem_dlg.exec_()
        if result:
            criteria = self.additem_dlg.coreText.text()
            tab = QWidget()
            tabTree = QTreeWidget()
            #print(tabTree)
            tabLayout = QVBoxLayout()

            tabLayout.addWidget(tabTree)
            tabLayout.setSizeConstraint(QLayout.SetFixedSize)
            tabTree.setFixedWidth(810)
            tabTree.setFixedHeight(300)
            tabTree.setColumnCount(2)
            tabTree.setHeaderLabels(['Search Text', 'Written Text'])
            tab.setLayout(tabLayout)
            self.criteriaTabs.insertTab(self.criteriaTabs.count(), tab, criteria)
            #print(tab.children())
            self.dynamicLayersList()

    def removeCriteriaTab(self):
        if self.criteriaTabs.count() > 1:
            self.criteriaTabs.removeTab(self.criteriaTabs.currentIndex())
            self.dynamicLayersList()

    def moveUpCriteriaTab(self):
        loc = self.criteriaTabs.currentIndex()
        if loc > 0:
            name = self.criteriaTabs.tabText(loc)
            widget = self.criteriaTabs.currentWidget()
            self.criteriaTabs.removeTab(loc)
            self.criteriaTabs.insertTab(loc - 1, widget,name)
            self.dynamicLayersList()

    def addPropertyItem(self):
        self.additem_dlg = mbb_dialog_additem()
        self.additem_dlg.show()
        result = self.additem_dlg.exec_()
        if result:
            item = self.additem_dlg.coreText.text()
            if len(self.additem_dlg.altText.text()) == 0:
                alt = self.additem_dlg.coreText.text()
            else:
                alt = self.additem_dlg.altText.text()

            tab = self.criteriaTabs.currentWidget()
            # print(tab)
            # tabLayout = tab.layout()
            # print(tabLayout)
            treeWidget = tab.children()[1]
            #print(treeWidget)
            if len(treeWidget.selectedItems()) == 0:#item not selected:
                twi = QTreeWidgetItem(treeWidget,[item, alt],0)
                twi.addChild(QTreeWidgetItem([self.otherItem, alt],0))
                treeWidget.expandItem(twi)
            else: #item selected:
                twi = treeWidget.currentItem()
                twi = QTreeWidgetItem(twi,[item, alt],0)
                twi.addChild(QTreeWidgetItem([self.otherItem, alt],0))
                treeWidget.expandItem(twi)


            self.dynamicLayersList()

    def removePropertyItem(self):
        tab = self.criteriaTabs.currentWidget()
        tw = tab.children()[1]

        for item in tw.selectedItems():
            idx = tw.indexOfTopLevelItem(item)
            if idx != -1:
                tw.takeTopLevelItem(idx)
            else:
                twi = item.parent()
                idx = twi.indexOfChild(item)
                twi.takeChild(idx)


        self.dynamicLayersList()

    def moveUpPropertyItem(self):
        tab = self.criteriaTabs.currentWidget()
        tw = tab.children()[1]

        for item in tw.selectedItems():
            idx = tw.indexOfTopLevelItem(item)
            if idx != -1:
                if idx > 0:
                    item = tw.takeTopLevelItem(idx)
                    tw.insertTopLevelItem(idx - 1, item)
            else:
                twi = item.parent()
                idx = twi.indexOfChild(item)
                if idx > 0:
                    item = twi.takeChild(idx)
                    twi.insertChild(idx - 1, item)


        self.dynamicLayersList()

    def deselectProperty(self):
        tab = self.criteriaTabs.currentWidget()
        tw = tab.children()[1]

        tw.clearSelection()

#Secondary Dynamic Layers
    def addSDLTab(self):
        self.additem_dlg = mbb_dialog_additem()
        self.additem_dlg.show()
        result = self.additem_dlg.exec_()
        if result:
            SDL = self.additem_dlg.coreText.text()
            tab = QWidget()
            tabTree = QTreeWidget()
            #print(tabTree)
            tabLayout = QVBoxLayout()

            tabLayout.addWidget(tabTree)
            tabLayout.setSizeConstraint(QLayout.SetFixedSize)
            tabTree.setFixedWidth(810)
            tabTree.setFixedHeight(300)
            tabTree.setColumnCount(3)
            tab.setLayout(tabLayout)
            self.SDLItems.insertTab(self.SDLItems.count(), tab, SDL)
            #print(tab.children())
            self.dynamicLayersList()

    def removeSDLTab(self):
        if self.SDLItems.count() > 0:
            self.SDLItems.removeTab(self.SDLItems.currentIndex())
            self.dynamicLayersList()

    def addSDLItem(self):
        self.additem_dlg = mbb_dialog_additem()
        self.additem_dlg.show()
        result = self.additem_dlg.exec_()
        if result:
            item = self.additem_dlg.coreText.text()
            tab = self.SDLItems.currentWidget()
            # print(tab)
            # tabLayout = tab.layout()
            # print(tabLayout)
            treeWidget = tab.children()[1]
            #print(treeWidget)
            twi = QTreeWidgetItem(treeWidget,[item],0)
            treeWidget.expandItem(twi)
            self.dynamicLayersList()

    def removeSDLItem(self):
        tab = self.SDLItems.currentWidget()
        tw = tab.children()[1]

        for item in tw.selectedItems():
            idx = tw.indexOfTopLevelItem(item)
            if idx != -1:
                tw.takeTopLevelItem(idx)



        self.dynamicLayersList()

    def addSDLProperty(self):
        self.additem_dlg = mbb_dialog_additem()
        self.additem_dlg.show()
        result = self.additem_dlg.exec_()
        if result:
            item = self.additem_dlg.coreText.text()

            tab = self.SDLItems.currentWidget()

            treeWidget = tab.children()[1]
            if len(treeWidget.selectedItems()) != 0:#item selected:
                twi = treeWidget.currentItem()
                twi = QTreeWidgetItem(twi,['Property','', item],0)
            self.dynamicLayersList()



    def addSDLExistingProperty(self):
        self.addProperty_dlg = mbb_dialog_addproperty(self.criteriaTabs)
        self.addProperty_dlg.show()
        result = self.addProperty_dlg.exec_()
        if result:
            item = self.addProperty_dlg.item.currentText()
            property = self.addProperty_dlg.property.currentText()

            tab = self.SDLItems.currentWidget()

            treeWidget = tab.children()[1]
            if len(treeWidget.selectedItems()) != 0:#item selected:
                twi = treeWidget.currentItem()
                twi = QTreeWidgetItem(twi,['Existing Property',item,''],0)
            self.dynamicLayersList()


    def addSDLCriteria(self):
        self.addProperty_dlg = mbb_dialog_addproperty(self.criteriaTabs)
        self.addProperty_dlg.show()
        result = self.addProperty_dlg.exec_()
        if result:
            item = self.addProperty_dlg.item.currentText()
            property = self.addProperty_dlg.property.currentText()

            tab = self.SDLItems.currentWidget()

            treeWidget = tab.children()[1]
            if len(treeWidget.selectedItems()) != 0:#item selected:
                twi = treeWidget.currentItem()
                twi = QTreeWidgetItem(twi,['Criteria',item, property],0)
            self.dynamicLayersList()


    def removeSDLFeature(self):
        tab = self.SDLItems.currentWidget()
        tw = tab.children()[1]

        for item in tw.selectedItems():
            idx = tw.indexOfTopLevelItem(item)
            if idx == -1:
                twi = item.parent()
                idx = twi.indexOfChild(item)
                twi.takeChild(idx)
        self.dynamicLayersList()


#
    def returnValues(self):

        return self.headerLength, os.path.join(self.setupPath, self.setupName + ".QMapSetup"), self.template, self.templateMaps

    def setupTemplate(self):
        self.newLayout = self.layoutTemplate.isChecked()
        if self.newLayout:
            if (self.newLayoutName.text() == '') or (self.newLayoutName.text() in self.allLayoutNames):
                print('Invalid Layout Name')
                return False


            if os.path.exists(self.existingTemplate.text()):
                self.template = QgsPrintLayout(QgsProject.instance())
                with open(self.existingTemplate.text()) as f:
                    template_content = f.read()
                doc = QDomDocument()
                doc.setContent(template_content)

                # adding to existing items
                self.template.loadFromTemplate(doc, QgsReadWriteContext())

                self.template.setName(self.newLayoutName.text())

                #manager = QgsProject.instance().layoutManager()
                #manager.addLayout(self.template)

            else:
                #Give warning not able to load
                print('No File')
                return False



        else:
            manager = QgsProject.instance().layoutManager()
            for layout in manager.printLayouts():
                if layout.name() == self.existingLayouts.currentText():
                    self.template = layout

        #find maps in template
        self.templateMaps = []
        for i in self.template.items():
            if isinstance(i, QgsLayoutItemMap):
                self.templateMaps.append(i)

        if len(self.templateMaps) == 0:
            #Give warning no maps in template
            print('No Maps')
            return False
        else:
            #print(self.templateMaps)


            return True

    def loadExistingFile(self, item, fileType):
        file = QFileDialog.getOpenFileName(self,'Select File', '/home',fileType)
        if file[0] is not '':
            item.setText(file[0])

    def dynamicLayersList(self):
        self.dynamicLayers = []
        lyrs = list(self.layers)
        for lyr in lyrs:
            lyr[1]=[]
        searchLists = []
        headerLabels=['Lead Dynamic Layer']
        for i in range(0, self.criteriaTabs.count()):
            tab = self.criteriaTabs.widget(i)
            treeWidget = tab.children()[1]
            searchList = self.createSearchList(treeWidget)
            headerLabels.append(self.criteriaTabs.tabText(i))
            lyrs = self.deepSearch(lyrs,searchList)

        for i in range(0, self.SDLItems.count()):
            tab = self.SDLItems.widget(i)
            treeWidget = tab.children()[1]
            headerLabels.append('<><> SECONDARY <><> ' + self.SDLItems.tabText(i))



        self.previewTree.clear()
        self.previewTree.setColumnCount(0)
        self.previewTree.setHeaderLabels(headerLabels)

        sdlCon = []
        for i in range(0, self.SDLItems.count()):
            tab = self.SDLItems.widget(i)
            treeWidget = tab.children()[1]
            sdlIterator = QTreeWidgetItemIterator(treeWidget)
            crit =  []
            prop = []
            while sdlIterator.value():
                sdlItem = sdlIterator.value()
                if sdlItem.childCount() == 0:
                    if sdlItem.text(0) == 'Criteria':
                        crit.append(sdlItem.text(2))
                    elif sdlItem.text(0) == 'Property':
                        prop.append(sdlItem.text(2))
                    elif sdlItem.text(0) == 'Existing Property':
                        prop.append('<<E>>' + sdlItem.text(1))

                sdlIterator += 1
            sdlCon.append([crit,prop])

        #print(sdlCon)



        for layer in lyrs:
            #print(layer)
            cols = []
            cols.append(layer[0].name())
            cols.extend(layer[1])

            #ADD SDL to cols
            sd = []
            for sdl in sdlCon:
                if len(sdl[0])>0 or len(sdl[1])>0:
                    op = True
                    for cr in sdl[0]:
                        if cr not in layer[0].name():
                            op = False

                    if op:
                        #print(sdl[1])
                        #print(self.layers)
                        for ly in self.layers:
                            lyp = True
                            for pr in sdl[1]:
                                if pr not in ly[0].name():
                                    lyp = False
                            if lyp:
                                #print(ly)
                                sd.append(ly[0].name())
                        #print(sd)
                        cols.append(('|'.join(sd)))



            twi = QTreeWidgetItem(self.previewTree,cols,0)
            #print(layer[1])
        self.dynamicLayers = lyrs
        if len(self.dynamicLayers) > 0:
            return True
        else:
            print('No Layers')

    def confirmDynamicDetails(self):
        self.itemsHeaderQMS = []
        self.itemsHeaderQMS.extend(['easting', 'northing', 'dynamicLayer', 'pageName'])

    def loadQMS(self):
        #Read QMS file
        with open(QMSFile, newline='') as csvfile:
            reader = list(csv.reader(csvfile, delimiter=','))
            headerLength = reader[0][1]

#Map Items
    def selectMapItems(self):
        for i in range(0, self.mapItems.count()  - 1):
            self.mapItems.removeTab(i)

        for mapItem in self.templateMaps:
            tab = QWidget()
            tabTree = QTreeWidget()
            tabLayout = QVBoxLayout()
            tabLayout.addWidget(tabTree)
            tabLayout.setSizeConstraint(QLayout.SetFixedSize)
            tabTree.setFixedWidth(810)
            tabTree.setFixedHeight(550)
            tabTree.setColumnCount(2)
            tabTree.setHeaderLabels(['Layer Name', 'Included in Legend'])
            tab.setLayout(tabLayout)
            self.mapItems.insertTab(self.mapItems.count(), tab, mapItem.displayName())


        return True

    def addMapItem(self):
        self.addmap_dlg = mbb_dialog_addmap()
        layerList = self.addmap_dlg.layerList
        layers = QgsProject.instance().mapLayers()
        layerList.clear()
        layerList.addItem('<><> LEAD DYNAMIC LAYER <><>')
        for layer_id, layer in layers.items():
            layerList.addItem(layer.name())



        self.addmap_dlg.show()
        result = self.addmap_dlg.exec_()
        if result:
            tab = self.mapItems.currentWidget()
            treeWidget = tab.children()[1]
            for layer in layerList.selectedItems():
                item = layer.text()
                twi = QTreeWidgetItem(treeWidget,[item],0)

    def removeMapItem(self):
        tab = self.mapItems.currentWidget()
        tw = tab.children()[1]

        for item in tw.selectedItems():
            idx = tw.indexOfTopLevelItem(item)
            if idx != -1:
                tw.takeTopLevelItem(idx)
            else:
                twi = item.parent()
                idx = twi.indexOfChild(item)
                twi.takeChild(idx)

    def moveUpMapItem(self):
        tab = self.mapItems.currentWidget()
        tw = tab.children()[1]

        for item in tw.selectedItems():
            idx = tw.indexOfTopLevelItem(item)
            if idx != -1:
                if idx > 0:
                    item = tw.takeTopLevelItem(idx)
                    tw.insertTopLevelItem(idx - 1, item)
            else:
                twi = item.parent()
                idx = twi.indexOfChild(item)
                if idx > 0:
                    item = twi.takeChild(idx)
                    twi.insertChild(idx - 1, item)

    def confirmMapItems(self):
        self.mapsHeaderQMS = []
        self.mapsDetailsQMS = []

        for map in self.templateMaps:
            self.mapsHeaderQMS.extend([map.displayName() + '_Scale',  map.displayName() + '_Rotation', map.displayName() + '_Layers'])
            self.mapsDetailsQMS.append([map.displayName])
        return True

#Search Tools
    def deepSearch(self, layers, searchList):
        #print(layers)
        #print(searchList)
        output = []
        for search in searchList:

            research = []
            found = []
            if type(search) == list:
                #print('500')
                #print(search)

                for layer in layers:

                    #if search[0] == self.otherItem:
                    #    search[0] = ''
                    if (search[0][0] == self.otherItem) and (len(searchList) > 1):
                        negSearch = searchList.copy()
                        negSearch.remove(search)
                        if any(x[0][0] not in layer[0].name() for x in negSearch):
                            #print('510')
                            #print(x[0][1])
                            layer[1].append(search[0][1])
                            output.append(layer)
                            #print(output)
                            found.append(layer)
                    else:
                        if search[0] == self.otherItem:
                            search = ('',search[1])
                        if search[0][0] in layer[0].name():
                            research.append(layer)
                            found.append(layer)
                for layer in found:
                    layers.remove(layer)

                #print(research)
                #print(search[1])
                for item in self.deepSearch(research, search[1]):
                    #print('520')
                    #print(item)
                    #print(search[1][0][1])
                    #item[1].append(search[1][0][1])
                    output.append(item)
                    #print(output)
            else:
                #print('520')
                #print(search)

                for layer in layers:
                    if (search[0] == self.otherItem) and (len(searchList) > 1):
                        negSearch = searchList.copy()
                        #print(negSearch)
                        #print(search)
                        negSearch.remove(search)
                        #print(negSearch)
                        if any(x[0] not in layer[0].name() for x in negSearch):
                            #print('537')
                            #print(x[1])
                            layer[1].append(search[1])
                            output.append(layer)
                            #print(output)
                            found.append(layer)
                    else:
                        if search[0] == self.otherItem:
                            search = ('',search[1])
                        if search[0] in layer[0].name():
                            #print('545')
                            #print(search[1])
                            layer[1].append(search[1])
                            output.append(layer)
                            #print(output)
                            found.append(layer)
                for layer in found:
                    layers.remove(layer)
        return output

    def createSearchList(self, treeWidget):
        items = []
        searchList = []
        for idx in range(treeWidget.topLevelItemCount()):
            items.append(treeWidget.topLevelItem(idx))
        #print(items)
        searchList = self.createSearchLists(items)
        return searchList

    def createSearchLists(self, levelItems):
        searchList = []
        if any(item.childCount() != 0 for item in levelItems):
            for item in levelItems:
                if item.childCount() != 0 :
                    items = []
                    for idx in range(item.childCount()):
                        items.append(item.child(idx))
                    rList = self.createSearchLists(items)
                else:
                    rList = [('',item.text(1))]

                searchList.append([(item.text(0), item.text(1)), rList])
        else:
            for item in levelItems:
                searchList.append((item.text(0), item.text(1)))

        return searchList

    def load_all_layers(self, group, layers):
        for child in group:
            if isinstance(child, QgsLayerTreeLayer):
                layers.append(child,[])
            elif isinstance(child, QgsLayerTreeGroup):
                layers = self.load_all_layers(child.children(), layers)
        return layers
